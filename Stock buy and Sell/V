class Solution {
public:
    int t[10005][3];
    int recAndMemo(int i,  int buy,vector<int>& prices){
        if(i>=prices.size()) return 0;
        int profit=0;
        if(t[i][buy]!=-1) return t[i][buy];
        if(buy){
            profit=max((-prices[i]+recAndMemo(i+1,0,prices)),(recAndMemo(i+1,1,prices)));
        }
        else
            profit=max((prices[i]+recAndMemo(i+2,1,prices)),(recAndMemo(i+1,0,prices)));
            return t[i][buy]= profit;

    }

    int tab(vector<int>& prices){
        memset(t,0,sizeof(t));
        int n=prices.size();

        for(int i=n-1;i>=0;i--){
            for(int buy=0;buy<=1;buy++){
                int profit=0;
                if(buy){
                    profit=max((-prices[i]+t[i+1][0]),(t[i+1][1]));
                }
                else
                    profit=max((prices[i]+t[i+2][1]),(t[i+1][0]));
                    t[i][buy]=profit;
            }
            
        }
            return t[0][1];
        
    }


   int spaceOpt(vector<int>& prices){
    int n = prices.size();

    int ahead_buy = 0;   // dp[i+1][1]
    int ahead_sell = 0;  // dp[i+1][0]

    int ahead2_buy = 0;  // dp[i+2][1]
    int ahead2_sell = 0; // dp[i+2][0]

    for(int i = n-1; i >= 0; i--){

        // curr buy state
        int curr_buy = max(
            -prices[i] + ahead_sell,   // BUY
            ahead_buy                 // SKIP
        );

        // curr sell state
        int curr_sell = max(
            prices[i] + ahead2_buy,    // SELL (cooldown â†’ uses i+2)
            ahead_sell                 // SKIP
        );

        // shift states:
        ahead2_buy  = ahead_buy;
        ahead2_sell = ahead_sell;

        ahead_buy   = curr_buy;
        ahead_sell  = curr_sell;
    }

    return ahead_buy;  // dp[0][1]
}

    int maxProfit(vector<int>& prices) {
            // memset(t,-1,sizeof(t));
            // return recAndMemo(0,1,prices);
            // return tab(prices);
            return spaceOpt(prices);
    }
};
