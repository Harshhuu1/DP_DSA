NON-Memoized->
class Solution {
public:
    int solve(int e, int f){
        if(f==0 || f==1) return f;
        if(e==1) return f;
        int mn=INT_MAX;
        for(int k=1;k<=f;k++){
            int temp=1+max(solve(e-1,f-1) , solve(e,f-k));
            mn=min(mn,temp);
        }
        return mn;
    }
    int superEggDrop(int k, int n) {
        return solve(k,n);
    }
};
Memoized->
class Solution {
public:
    int t[105][10005];
    int solve(int e, int f){
        if(f==0 || f==1) return f;
        if(e==1) return f;
        if([e][f]!=-1) return t[e][f];
        int mn=INT_MAX;
        for(int k=1;k<=f;k++){
            int temp=1+max(solve(e-1,f-1) , solve(e,f-k));
            mn=min(mn,temp);
        }
        return t[e][f]= mn;
    }
    int superEggDrop(int k, int n) {
       memset(t,-1,sizeof(t));
      return solve(k,n);
    }
};
Memoized + more optimized->
class Solution {
public:
    int t[105][10005];
    int solve(int e, int f){
        if(f==0 || f==1) return f;
        //use binary search to get most optimized
        if(e==1) return f;
        int low=0;
        int high=f;
        

        if(t[e][f]!=-1){
            return t[e][f];
        }
        int mn=INT_MAX;
        while(low<=high){
            int mid=(low+high)/2;
            int left=solve(e-1,mid-1);
            int right=solve(e,f-mid);
            int temp=1+max(left,right);
            if(left<right){
                low=mid+1;
            }
            else
            high=mid-1;
            mn=min(mn,temp);
        }
        return t[e][f] =mn;

    }
    int superEggDrop(int k, int n) {
        memset(t,-1,sizeof(t));
        return solve(k,n);
    }
};
