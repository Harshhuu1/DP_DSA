class Solution {
public:
    // int solve(int i,int j,int n,int m,vector<vector<int>>&
    // matrix,vector<vector<int>>&dp){

    //      if (i >= n || j >= m || j < 0) return INT_MAX;
    //     if(i==n-1) return matrix[i][j];
    //     if(dp[i][j]!=-1) return dp[i][j];

    //     return
    //     dp[i][j]=matrix[i][j]+min({solve(i+1,j-1,n,m,matrix,dp),solve(i+1,j,n,m,matrix,dp),
    //                             solve(i+1,j+1,n,m,matrix,dp)});
    // }
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int m = matrix[0].size();
        vector<vector<int>> dp(n, vector<int>(m, -1));
        vector<int> prev(m,0);
        
        for (int j = 0; j < m; j++) {
            prev[j] = matrix[0][j];
        }
        

        for (int i = 1; i < n; i++) {
                vector<int> curri(m,0);
            for (int j = 0; j < m; j++) {
                int left = INT_MAX, down = INT_MAX, right = INT_MAX;

                if (j + 1 < m)
                    left = matrix[i][j] + prev[j + 1];

                down = matrix[i][j] + prev[j];

                if (j - 1 >= 0)
                    right = matrix[i][j] + prev[j - 1];

               curri[j] =min({left, down, right});
            }
            prev=curri;
            
        }

        // try all starting columns from top row
        // for (int j = 0; j < m; j++) {
        //     mini = min(mini, solve(0, j, n, m, matrix,dp));
        // }
        int mini = INT_MAX;
        for (int j = 0; j < m; j++) {
            mini = min(mini, prev[j]);
        }

        return mini;
    }
};
